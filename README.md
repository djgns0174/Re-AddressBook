## 객체지향 주소록

### 목표

- 앞서 만든 주소록에 대해서 객체지향적으로 바꾸는 프로젝트
- 객체지향 개념을 적용하여 이것이 c++이다 강의 내용 복습하는 차원
- MVC 개념을 적용 → 유지보수 용이성
- 모듈간의 결합도를 낮추고 코드의 가독성을 올리는것.

### 프로젝트 진행하면서 궁금점

- 널널한 개발자 피셜 → 데이터, 화면 그리고 나머지로 객체화를 해라.
    - 궁금점
        1. 데이터에 대해서 객체화를 하면 자료구조, 노드, 대상 데이터에 대해서 분할을 해야되는것인가 아니면 하나로 객체화를 해야되는것인가?
            
             → 자료구조, 노드, 대상데이터에 대해서는 따로 클래스화하는게 좋다. 자료구조→노드→대상데이터 이렇게 의존관계가 존재하고 제일 중요한 것은 추상클래스를 생성해서 파생클래스로 자료구조에 대한 인스턴스(List)를 만들어서 언제든지 갈아끼울수 있게 한다. (아래의 코드 참조)
            
        
        ```cpp
        Parent* list = new List();
        Parent* tree = new Tree();
        
        UI* ui1 = new UI(list, mlist); -> 자료구조 list 사용
        UI* ui2 = new UI(tree, mtree); -> 자료구조 tree 사용
        
        EventHandler* eh = new EventHandler(ui1 or ui2);
        ```
        
        1. 화면에 대해서는 어떻게 객체화를 하나? 멤버메소드로 데이터출력 같은것을 정의하면 데이터에 대한 의존성은 존재할수 밖에 없지 않나? 
            
            → 이벤트 반복문에 대한 객체, UI에 대한 객체로 분리 시켜서 이벤트 반복문에 대해서는 사용자가 기능을 입력받게 해놓았고 기능별로 인풋값 파싱하는 부분등은 UI에 대한 객체에서 역할을 수행하게 했음. 데이터에 대한 의존성은 어쩔 수 없이 존재하지만 데이터에 대해서가 아닌 추상클래스에 대해서 의존성을 두었다. 때문에 인스턴스에 대해서 언제든지 갈아 끼울 준비가 돼있음. (List에서 Tree로 바뀌어도 UI쪽은 영향이 없음)
            
            ```cpp
            class UI{
            private:
            	DataStructure* ds; // 전체연락처
            	DataStructure* mds; //즐겨찾기 연락처	
            }
            ```
            
        2. 그리고 각각의 모듈에 대한 의존성은 어떻게 해결할것인가?
            
            → list, node, data 순서로 단방향 의존관계가 있음. 이들에 대한 연관관계는 어쩔수 없다고 결론지음. 
            
    
    ### 구현결과
    
    1차 
    
    1. How
    - View : 이벤트 핸들러, UI 결합
    - Model : List, Node, Data 각각의 인스턴스
    - Controller : 사용자의 기능함수 (add, mark 등)
    
    ```cpp
     main → run(이벤트핸들러) → 사용자 기능함수 → List → Node → Data
    ```
    
    1. 잘한점
        
        → 멤버객체를 포인터로 간접접근 : 
        
        노드의 멤버로 대상자료에 대한  포인터(참조)로 간접적으로 접근을 하게 한다. 간접적으로 접근하게 되면 매개변수로 받은 객체를 해당 클래스내에서 다시 멤버객체로 생성을 하지 않고 참조만 하기 때문에 메모리측면에서 효율성을 챙길 수 있다.
        
        → private 키워드 사용 : 
        
        노드는 대상 자료가 구체적으로 무슨 멤버를 가지는지 등에 대한 정보는 몰라도 되게 설계할 수 있다. 대상자료에 대한 멤버들은 private으로 은닉화를 시키고 public으로 접근해도 되는 멤버들만 접근하게 하면 된다. 즉 private 키워드를 사용하게 되면 정보를 은닉화 할 수 있고 모듈간의 의존성도 낮출 수 있다. 
        
        ```cpp
        class Node {
        private:
        	Node* prev;
        	Node* next;
        	Data* data;
        public:
        	Node() { 
        		this->prev = nullptr; 
        		this->next = nullptr;
        		this->data = nullptr;
        	};
        	Node(Node* pPrev, Node* pNext, Data* pData) : prev(pPrev), next(pNext), data(pData) {};
        	~Node() {
        		cout << "Node 소멸자 호출" << endl;
        	}
        };
        ```
        
    2. 문제점
    - 위와같이 자료구조가 아닌 인스턴스를 의존하고 있기 때문에 List에서 Tree로 교체하면 코드를 전부 바꿔줘야된다.
    - UI 클래스를 직접 구현하지 않았고 기능함수를 각각 정의를 했기 때문에 코드 가독성이 떨어진다. 또한 List 클래스의 메소드로 선언을 하지 않고 헤더파일에 markNode 등의 함수를 선언을 했기 때문에 클래스 내부 메소드로 선언을 해줘야 한다.
    
    2차 
    
    1. How
    
    ```cpp
    main → EventHandler → UI → DataStructure → List → Node → Data
    ```
    
    - EventHandler, UI 클래스를 분리시켜서 단일 책임 원칙을 준수하였음.
    - 앞서 1차에서 사용자 기능함수를 UI클래스의 내부함수로 정의하였고, List도 동일하게 내부함수로 정의하였음.
    - UI와 List의 의존성을 줄이기 위해서 List의 추상클래스인 DataStructure를 생성하여서 List에서 Tree로 자료구조를 교체하더라도 사용자 코드는 수정하지 않도록 구현하였음.
    1. 잘한점
        - 모듈을 세분화시켜서 단일 책임 원칙을 준수하게 하였음.
        - 추상클래스를 생성하여서 사용자 코드쪽에서는 추상클래스를 의존함으로써 사용자 코드와 제작자 코드간의 의존성을 줄였음.
        - 클래스 내부 메서드를 재정의함으로써 코드의 가독성을 올렸음.
    2. 문제점
        - List, Node, Data 각각의 모듈간의 의존성은 여전히 존재하여 이중연결리스트가 추가되는 등, 확장성에 대한 고려는 충분하지 않음.

### 얻은점

1. 객체지향 프로그래밍을 할때는 모듈간의 관계에 대한 설계가 매우 중요하다.
2. 확장성을 고려하여 구현해야 하고 의존성에 대한 문제는 추상클래스와 가상함수 등으로 해결할 수 있다.
3. 모듈간의 의존성에 대해서 고려를 할 때는 사용코드쪽에서 모듈을 교체 한다고 가정했을 때 어떤 문제가 발생하는지 보고 설계를 다시 해야한다.
4. 은닉화를 통해 사용자 쪽에서 모듈을 사용할 때 해당 모듈이 구체적으로 어떤 멤버를 갖고 있는지 몰라도 되게 설계를 하여 의존성을 낮출 수 있다. 
5. 멤버 객체를 포인터로 간접접근하게 되면 해당 클래스를 선언할때 객체를 생성하지 않기 때문에 메모리를 효율적으로 사용할 수 있다. (매개변수로 참조자를 사용할때도 마찬가지)
